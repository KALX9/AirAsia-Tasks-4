[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ terraform init

Initializing the backend...

Initializing provider plugins...
- Using previously-installed hashicorp/aws v3.75.2

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ clear
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ ## Terraform Steps for building EKS Infa
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ terraform init

Initializing the backend...

Initializing provider plugins...
- Using previously-installed hashicorp/aws v3.75.2

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ terraform plan
Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.


------------------------------------------------------------------------

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_eip.nat1 will be created
  + resource "aws_eip" "nat1" {
      + allocation_id        = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = (known after apply)
      + id                   = (known after apply)
      + instance             = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags_all             = (known after apply)
      + vpc                  = (known after apply)
    }

  # aws_eip.nat2 will be created
  + resource "aws_eip" "nat2" {
      + allocation_id        = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = (known after apply)
      + id                   = (known after apply)
      + instance             = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags_all             = (known after apply)
      + vpc                  = (known after apply)
    }

  # aws_eks_cluster.demo will be created
  + resource "aws_eks_cluster" "demo" {
      + arn                   = (known after apply)
      + certificate_authority = (known after apply)
      + created_at            = (known after apply)
      + endpoint              = (known after apply)
      + id                    = (known after apply)
      + identity              = (known after apply)
      + name                  = "demo"
      + platform_version      = (known after apply)
      + role_arn              = (known after apply)
      + status                = (known after apply)
      + tags_all              = (known after apply)
      + version               = (known after apply)

      + kubernetes_network_config {
          + ip_family         = (known after apply)
          + service_ipv4_cidr = (known after apply)
        }

      + vpc_config {
          + cluster_security_group_id = (known after apply)
          + endpoint_private_access   = false
          + endpoint_public_access    = true
          + public_access_cidrs       = (known after apply)
          + subnet_ids                = (known after apply)
          + vpc_id                    = (known after apply)
        }
    }

  # aws_eks_node_group.private-nodes will be created
  + resource "aws_eks_node_group" "private-nodes" {
      + ami_type               = (known after apply)
      + arn                    = (known after apply)
      + capacity_type          = "ON_DEMAND"
      + cluster_name           = "demo"
      + disk_size              = (known after apply)
      + id                     = (known after apply)
      + instance_types         = [
          + "t3.small",
        ]
      + labels                 = {
          + "role" = "general"
        }
      + node_group_name        = "private-nodes"
      + node_group_name_prefix = (known after apply)
      + node_role_arn          = (known after apply)
      + release_version        = (known after apply)
      + resources              = (known after apply)
      + status                 = (known after apply)
      + subnet_ids             = (known after apply)
      + tags_all               = (known after apply)
      + version                = (known after apply)

      + scaling_config {
          + desired_size = 1
          + max_size     = 5
          + min_size     = 0
        }

      + update_config {
          + max_unavailable = 1
        }
    }

  # aws_iam_role.demo will be created
  + resource "aws_iam_role" "demo" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "eks.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "eks-cluster-demo"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy {
          + name   = (known after apply)
          + policy = (known after apply)
        }
    }

  # aws_iam_role.nodes will be created
  + resource "aws_iam_role" "nodes" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "ec2.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "eks-node-group-nodes"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy {
          + name   = (known after apply)
          + policy = (known after apply)
        }
    }

  # aws_iam_role_policy_attachment.demo-AmazonEKSClusterPolicy will be created
  + resource "aws_iam_role_policy_attachment" "demo-AmazonEKSClusterPolicy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
      + role       = "eks-cluster-demo"
    }

  # aws_iam_role_policy_attachment.nodes-AmazonEC2ContainerRegistryReadOnly will be created
  + resource "aws_iam_role_policy_attachment" "nodes-AmazonEC2ContainerRegistryReadOnly" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
      + role       = "eks-node-group-nodes"
    }

  # aws_iam_role_policy_attachment.nodes-AmazonEKSWorkerNodePolicy will be created
  + resource "aws_iam_role_policy_attachment" "nodes-AmazonEKSWorkerNodePolicy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
      + role       = "eks-node-group-nodes"
    }

  # aws_iam_role_policy_attachment.nodes-AmazonEKS_CNI_Policy will be created
  + resource "aws_iam_role_policy_attachment" "nodes-AmazonEKS_CNI_Policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
      + role       = "eks-node-group-nodes"
    }

  # aws_internet_gateway.main will be created
  + resource "aws_internet_gateway" "main" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + owner_id = (known after apply)
      + tags     = {
          + "Name" = "main"
        }
      + tags_all = {
          + "Name" = "main"
        }
      + vpc_id   = (known after apply)
    }

  # aws_nat_gateway.gw1 will be created
  + resource "aws_nat_gateway" "gw1" {
      + allocation_id        = (known after apply)
      + connectivity_type    = "public"
      + id                   = (known after apply)
      + network_interface_id = (known after apply)
      + private_ip           = (known after apply)
      + public_ip            = (known after apply)
      + subnet_id            = (known after apply)
      + tags                 = {
          + "Name" = "NAT 1"
        }
      + tags_all             = {
          + "Name" = "NAT 1"
        }
    }

  # aws_nat_gateway.gw2 will be created
  + resource "aws_nat_gateway" "gw2" {
      + allocation_id        = (known after apply)
      + connectivity_type    = "public"
      + id                   = (known after apply)
      + network_interface_id = (known after apply)
      + private_ip           = (known after apply)
      + public_ip            = (known after apply)
      + subnet_id            = (known after apply)
      + tags                 = {
          + "Name" = "NAT 2"
        }
      + tags_all             = {
          + "Name" = "NAT 2"
        }
    }

  # aws_route_table.private1 will be created
  + resource "aws_route_table" "private1" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + carrier_gateway_id         = ""
              + cidr_block                 = "0.0.0.0/0"
              + destination_prefix_list_id = ""
              + egress_only_gateway_id     = ""
              + gateway_id                 = ""
              + instance_id                = ""
              + ipv6_cidr_block            = ""
              + local_gateway_id           = ""
              + nat_gateway_id             = (known after apply)
              + network_interface_id       = ""
              + transit_gateway_id         = ""
              + vpc_endpoint_id            = ""
              + vpc_peering_connection_id  = ""
            },
        ]
      + tags             = {
          + "Name" = "private1"
        }
      + tags_all         = {
          + "Name" = "private1"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table.private2 will be created
  + resource "aws_route_table" "private2" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + carrier_gateway_id         = ""
              + cidr_block                 = "0.0.0.0/0"
              + destination_prefix_list_id = ""
              + egress_only_gateway_id     = ""
              + gateway_id                 = ""
              + instance_id                = ""
              + ipv6_cidr_block            = ""
              + local_gateway_id           = ""
              + nat_gateway_id             = (known after apply)
              + network_interface_id       = ""
              + transit_gateway_id         = ""
              + vpc_endpoint_id            = ""
              + vpc_peering_connection_id  = ""
            },
        ]
      + tags             = {
          + "Name" = "private2"
        }
      + tags_all         = {
          + "Name" = "private2"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table.public will be created
  + resource "aws_route_table" "public" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + carrier_gateway_id         = ""
              + cidr_block                 = "0.0.0.0/0"
              + destination_prefix_list_id = ""
              + egress_only_gateway_id     = ""
              + gateway_id                 = (known after apply)
              + instance_id                = ""
              + ipv6_cidr_block            = ""
              + local_gateway_id           = ""
              + nat_gateway_id             = ""
              + network_interface_id       = ""
              + transit_gateway_id         = ""
              + vpc_endpoint_id            = ""
              + vpc_peering_connection_id  = ""
            },
        ]
      + tags             = {
          + "Name" = "public"
        }
      + tags_all         = {
          + "Name" = "public"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table_association.private-ap-south-1a will be created
  + resource "aws_route_table_association" "private-ap-south-1a" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.private-ap-south-1b will be created
  + resource "aws_route_table_association" "private-ap-south-1b" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.public-ap-south-1a will be created
  + resource "aws_route_table_association" "public-ap-south-1a" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.public-ap-south-1b will be created
  + resource "aws_route_table_association" "public-ap-south-1b" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_subnet.private-ap-south-1a will be created
  + resource "aws_subnet" "private-ap-south-1a" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "ap-south-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "192.168.128.0/18"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"                            = "private-ap-south-1a"
          + "kubernetes.io/cluster/eks"       = "shared"
          + "kubernetes.io/role/internal-elb" = "1"
        }
      + tags_all                                       = {
          + "Name"                            = "private-ap-south-1a"
          + "kubernetes.io/cluster/eks"       = "shared"
          + "kubernetes.io/role/internal-elb" = "1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.private-ap-south-1b will be created
  + resource "aws_subnet" "private-ap-south-1b" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "ap-south-1b"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "192.168.192.0/18"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"                            = "private-ap-south-1b"
          + "kubernetes.io/cluster/eks"       = "shared"
          + "kubernetes.io/role/internal-elb" = "1"
        }
      + tags_all                                       = {
          + "Name"                            = "private-ap-south-1b"
          + "kubernetes.io/cluster/eks"       = "shared"
          + "kubernetes.io/role/internal-elb" = "1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.public-ap-south-1a will be created
  + resource "aws_subnet" "public-ap-south-1a" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "ap-south-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "192.168.0.0/18"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = true
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"                      = "public-ap-south-1a"
          + "kubernetes.io/cluster/eks" = "shared"
          + "kubernetes.io/role/elb"    = "1"
        }
      + tags_all                                       = {
          + "Name"                      = "public-ap-south-1a"
          + "kubernetes.io/cluster/eks" = "shared"
          + "kubernetes.io/role/elb"    = "1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.public-ap-south-1b will be created
  + resource "aws_subnet" "public-ap-south-1b" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "ap-south-1b"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "192.168.64.0/18"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = true
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"                      = "public-ap-south-1b"
          + "kubernetes.io/cluster/eks" = "shared"
          + "kubernetes.io/role/elb"    = "1"
        }
      + tags_all                                       = {
          + "Name"                      = "public-ap-south-1b"
          + "kubernetes.io/cluster/eks" = "shared"
          + "kubernetes.io/role/elb"    = "1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_vpc.main will be created
  + resource "aws_vpc" "main" {
      + arn                                  = (known after apply)
      + cidr_block                           = "192.168.0.0/16"
      + default_network_acl_id               = (known after apply)
      + default_route_table_id               = (known after apply)
      + default_security_group_id            = (known after apply)
      + dhcp_options_id                      = (known after apply)
      + enable_classiclink                   = (known after apply)
      + enable_classiclink_dns_support       = (known after apply)
      + enable_dns_hostnames                 = (known after apply)
      + enable_dns_support                   = true
      + id                                   = (known after apply)
      + instance_tenancy                     = "default"
      + ipv6_association_id                  = (known after apply)
      + ipv6_cidr_block                      = (known after apply)
      + ipv6_cidr_block_network_border_group = (known after apply)
      + main_route_table_id                  = (known after apply)
      + owner_id                             = (known after apply)
      + tags                                 = {
          + "Name" = "main"
        }
      + tags_all                             = {
          + "Name" = "main"
        }
    }

Plan: 25 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + vpc_id = (known after apply)

------------------------------------------------------------------------

Note: You didn't specify an "-out" parameter to save this plan, so Terraform
can't guarantee that exactly these actions will be performed if
"terraform apply" is subsequently run.

[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ terraform apply

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_eip.nat1 will be created
  + resource "aws_eip" "nat1" {
      + allocation_id        = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = (known after apply)
      + id                   = (known after apply)
      + instance             = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags_all             = (known after apply)
      + vpc                  = (known after apply)
    }

  # aws_eip.nat2 will be created
  + resource "aws_eip" "nat2" {
      + allocation_id        = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = (known after apply)
      + id                   = (known after apply)
      + instance             = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags_all             = (known after apply)
      + vpc                  = (known after apply)
    }

  # aws_eks_cluster.demo will be created
  + resource "aws_eks_cluster" "demo" {
      + arn                   = (known after apply)
      + certificate_authority = (known after apply)
      + created_at            = (known after apply)
      + endpoint              = (known after apply)
      + id                    = (known after apply)
      + identity              = (known after apply)
      + name                  = "demo"
      + platform_version      = (known after apply)
      + role_arn              = (known after apply)
      + status                = (known after apply)
      + tags_all              = (known after apply)
      + version               = (known after apply)

      + kubernetes_network_config {
          + ip_family         = (known after apply)
          + service_ipv4_cidr = (known after apply)
        }

      + vpc_config {
          + cluster_security_group_id = (known after apply)
          + endpoint_private_access   = false
          + endpoint_public_access    = true
          + public_access_cidrs       = (known after apply)
          + subnet_ids                = (known after apply)
          + vpc_id                    = (known after apply)
        }
    }

  # aws_eks_node_group.private-nodes will be created
  + resource "aws_eks_node_group" "private-nodes" {
      + ami_type               = (known after apply)
      + arn                    = (known after apply)
      + capacity_type          = "ON_DEMAND"
      + cluster_name           = "demo"
      + disk_size              = (known after apply)
      + id                     = (known after apply)
      + instance_types         = [
          + "t3.small",
        ]
      + labels                 = {
          + "role" = "general"
        }
      + node_group_name        = "private-nodes"
      + node_group_name_prefix = (known after apply)
      + node_role_arn          = (known after apply)
      + release_version        = (known after apply)
      + resources              = (known after apply)
      + status                 = (known after apply)
      + subnet_ids             = (known after apply)
      + tags_all               = (known after apply)
      + version                = (known after apply)

      + scaling_config {
          + desired_size = 1
          + max_size     = 5
          + min_size     = 0
        }

      + update_config {
          + max_unavailable = 1
        }
    }

  # aws_iam_role.demo will be created
  + resource "aws_iam_role" "demo" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "eks.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "eks-cluster-demo"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy {
          + name   = (known after apply)
          + policy = (known after apply)
        }
    }

  # aws_iam_role.nodes will be created
  + resource "aws_iam_role" "nodes" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "ec2.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "eks-node-group-nodes"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy {
          + name   = (known after apply)
          + policy = (known after apply)
        }
    }

  # aws_iam_role_policy_attachment.demo-AmazonEKSClusterPolicy will be created
  + resource "aws_iam_role_policy_attachment" "demo-AmazonEKSClusterPolicy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
      + role       = "eks-cluster-demo"
    }

  # aws_iam_role_policy_attachment.nodes-AmazonEC2ContainerRegistryReadOnly will be created
  + resource "aws_iam_role_policy_attachment" "nodes-AmazonEC2ContainerRegistryReadOnly" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
      + role       = "eks-node-group-nodes"
    }

  # aws_iam_role_policy_attachment.nodes-AmazonEKSWorkerNodePolicy will be created
  + resource "aws_iam_role_policy_attachment" "nodes-AmazonEKSWorkerNodePolicy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
      + role       = "eks-node-group-nodes"
    }

  # aws_iam_role_policy_attachment.nodes-AmazonEKS_CNI_Policy will be created
  + resource "aws_iam_role_policy_attachment" "nodes-AmazonEKS_CNI_Policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
      + role       = "eks-node-group-nodes"
    }

  # aws_internet_gateway.main will be created
  + resource "aws_internet_gateway" "main" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + owner_id = (known after apply)
      + tags     = {
          + "Name" = "main"
        }
      + tags_all = {
          + "Name" = "main"
        }
      + vpc_id   = (known after apply)
    }

  # aws_nat_gateway.gw1 will be created
  + resource "aws_nat_gateway" "gw1" {
      + allocation_id        = (known after apply)
      + connectivity_type    = "public"
      + id                   = (known after apply)
      + network_interface_id = (known after apply)
      + private_ip           = (known after apply)
      + public_ip            = (known after apply)
      + subnet_id            = (known after apply)
      + tags                 = {
          + "Name" = "NAT 1"
        }
      + tags_all             = {
          + "Name" = "NAT 1"
        }
    }

  # aws_nat_gateway.gw2 will be created
  + resource "aws_nat_gateway" "gw2" {
      + allocation_id        = (known after apply)
      + connectivity_type    = "public"
      + id                   = (known after apply)
      + network_interface_id = (known after apply)
      + private_ip           = (known after apply)
      + public_ip            = (known after apply)
      + subnet_id            = (known after apply)
      + tags                 = {
          + "Name" = "NAT 2"
        }
      + tags_all             = {
          + "Name" = "NAT 2"
        }
    }

  # aws_route_table.private1 will be created
  + resource "aws_route_table" "private1" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + carrier_gateway_id         = ""
              + cidr_block                 = "0.0.0.0/0"
              + destination_prefix_list_id = ""
              + egress_only_gateway_id     = ""
              + gateway_id                 = ""
              + instance_id                = ""
              + ipv6_cidr_block            = ""
              + local_gateway_id           = ""
              + nat_gateway_id             = (known after apply)
              + network_interface_id       = ""
              + transit_gateway_id         = ""
              + vpc_endpoint_id            = ""
              + vpc_peering_connection_id  = ""
            },
        ]
      + tags             = {
          + "Name" = "private1"
        }
      + tags_all         = {
          + "Name" = "private1"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table.private2 will be created
  + resource "aws_route_table" "private2" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + carrier_gateway_id         = ""
              + cidr_block                 = "0.0.0.0/0"
              + destination_prefix_list_id = ""
              + egress_only_gateway_id     = ""
              + gateway_id                 = ""
              + instance_id                = ""
              + ipv6_cidr_block            = ""
              + local_gateway_id           = ""
              + nat_gateway_id             = (known after apply)
              + network_interface_id       = ""
              + transit_gateway_id         = ""
              + vpc_endpoint_id            = ""
              + vpc_peering_connection_id  = ""
            },
        ]
      + tags             = {
          + "Name" = "private2"
        }
      + tags_all         = {
          + "Name" = "private2"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table.public will be created
  + resource "aws_route_table" "public" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + carrier_gateway_id         = ""
              + cidr_block                 = "0.0.0.0/0"
              + destination_prefix_list_id = ""
              + egress_only_gateway_id     = ""
              + gateway_id                 = (known after apply)
              + instance_id                = ""
              + ipv6_cidr_block            = ""
              + local_gateway_id           = ""
              + nat_gateway_id             = ""
              + network_interface_id       = ""
              + transit_gateway_id         = ""
              + vpc_endpoint_id            = ""
              + vpc_peering_connection_id  = ""
            },
        ]
      + tags             = {
          + "Name" = "public"
        }
      + tags_all         = {
          + "Name" = "public"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table_association.private-ap-south-1a will be created
  + resource "aws_route_table_association" "private-ap-south-1a" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.private-ap-south-1b will be created
  + resource "aws_route_table_association" "private-ap-south-1b" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.public-ap-south-1a will be created
  + resource "aws_route_table_association" "public-ap-south-1a" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.public-ap-south-1b will be created
  + resource "aws_route_table_association" "public-ap-south-1b" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_subnet.private-ap-south-1a will be created
  + resource "aws_subnet" "private-ap-south-1a" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "ap-south-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "192.168.128.0/18"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"                            = "private-ap-south-1a"
          + "kubernetes.io/cluster/eks"       = "shared"
          + "kubernetes.io/role/internal-elb" = "1"
        }
      + tags_all                                       = {
          + "Name"                            = "private-ap-south-1a"
          + "kubernetes.io/cluster/eks"       = "shared"
          + "kubernetes.io/role/internal-elb" = "1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.private-ap-south-1b will be created
  + resource "aws_subnet" "private-ap-south-1b" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "ap-south-1b"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "192.168.192.0/18"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"                            = "private-ap-south-1b"
          + "kubernetes.io/cluster/eks"       = "shared"
          + "kubernetes.io/role/internal-elb" = "1"
        }
      + tags_all                                       = {
          + "Name"                            = "private-ap-south-1b"
          + "kubernetes.io/cluster/eks"       = "shared"
          + "kubernetes.io/role/internal-elb" = "1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.public-ap-south-1a will be created
  + resource "aws_subnet" "public-ap-south-1a" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "ap-south-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "192.168.0.0/18"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = true
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"                      = "public-ap-south-1a"
          + "kubernetes.io/cluster/eks" = "shared"
          + "kubernetes.io/role/elb"    = "1"
        }
      + tags_all                                       = {
          + "Name"                      = "public-ap-south-1a"
          + "kubernetes.io/cluster/eks" = "shared"
          + "kubernetes.io/role/elb"    = "1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.public-ap-south-1b will be created
  + resource "aws_subnet" "public-ap-south-1b" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "ap-south-1b"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "192.168.64.0/18"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = true
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"                      = "public-ap-south-1b"
          + "kubernetes.io/cluster/eks" = "shared"
          + "kubernetes.io/role/elb"    = "1"
        }
      + tags_all                                       = {
          + "Name"                      = "public-ap-south-1b"
          + "kubernetes.io/cluster/eks" = "shared"
          + "kubernetes.io/role/elb"    = "1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_vpc.main will be created
  + resource "aws_vpc" "main" {
      + arn                                  = (known after apply)
      + cidr_block                           = "192.168.0.0/16"
      + default_network_acl_id               = (known after apply)
      + default_route_table_id               = (known after apply)
      + default_security_group_id            = (known after apply)
      + dhcp_options_id                      = (known after apply)
      + enable_classiclink                   = (known after apply)
      + enable_classiclink_dns_support       = (known after apply)
      + enable_dns_hostnames                 = (known after apply)
      + enable_dns_support                   = true
      + id                                   = (known after apply)
      + instance_tenancy                     = "default"
      + ipv6_association_id                  = (known after apply)
      + ipv6_cidr_block                      = (known after apply)
      + ipv6_cidr_block_network_border_group = (known after apply)
      + main_route_table_id                  = (known after apply)
      + owner_id                             = (known after apply)
      + tags                                 = {
          + "Name" = "main"
        }
      + tags_all                             = {
          + "Name" = "main"
        }
    }

Plan: 25 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + vpc_id = (known after apply)

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_vpc.main: Creating...
aws_iam_role.nodes: Creating...
aws_iam_role.demo: Creating...
aws_vpc.main: Creation complete after 0s [id=vpc-02d109b2d9081bd41]
aws_subnet.private-ap-south-1b: Creating...
aws_subnet.public-ap-south-1a: Creating...
aws_subnet.private-ap-south-1a: Creating...
aws_internet_gateway.main: Creating...
aws_subnet.public-ap-south-1b: Creating...
aws_internet_gateway.main: Creation complete after 1s [id=igw-0c4d359aa963ac732]
aws_route_table.public: Creating...
aws_eip.nat1: Creating...
aws_eip.nat2: Creating...
aws_subnet.private-ap-south-1b: Creation complete after 1s [id=subnet-01f6c4c8a43c93472]
aws_eip.nat2: Creation complete after 0s [id=eipalloc-043cd92e78e6ebf08]
aws_eip.nat1: Creation complete after 0s [id=eipalloc-08c4fadc1e365602e]
aws_subnet.private-ap-south-1a: Creation complete after 1s [id=subnet-03825e1046948a063]
aws_route_table.public: Creation complete after 0s [id=rtb-08b6a3e95120532d9]
aws_iam_role.demo: Creation complete after 3s [id=eks-cluster-demo]
aws_iam_role_policy_attachment.demo-AmazonEKSClusterPolicy: Creating...
aws_iam_role.nodes: Creation complete after 3s [id=eks-node-group-nodes]
aws_iam_role_policy_attachment.nodes-AmazonEKSWorkerNodePolicy: Creating...
aws_iam_role_policy_attachment.nodes-AmazonEKS_CNI_Policy: Creating...
aws_iam_role_policy_attachment.nodes-AmazonEC2ContainerRegistryReadOnly: Creating...
aws_iam_role_policy_attachment.demo-AmazonEKSClusterPolicy: Creation complete after 2s [id=eks-cluster-demo-20220615104412898300000001]
aws_iam_role_policy_attachment.nodes-AmazonEC2ContainerRegistryReadOnly: Creation complete after 2s [id=eks-node-group-nodes-20220615104412943800000003]
aws_iam_role_policy_attachment.nodes-AmazonEKSWorkerNodePolicy: Creation complete after 2s [id=eks-node-group-nodes-20220615104412939500000002]
aws_iam_role_policy_attachment.nodes-AmazonEKS_CNI_Policy: Creation complete after 2s [id=eks-node-group-nodes-20220615104412946600000004]
aws_subnet.public-ap-south-1a: Still creating... [10s elapsed]
aws_subnet.public-ap-south-1b: Still creating... [10s elapsed]
aws_subnet.public-ap-south-1a: Creation complete after 11s [id=subnet-0b4bb791f4d09ead4]
aws_subnet.public-ap-south-1b: Creation complete after 11s [id=subnet-0a8600553f73afd2d]
aws_route_table_association.public-ap-south-1a: Creating...
aws_eks_cluster.demo: Creating...
aws_route_table_association.public-ap-south-1b: Creating...
aws_nat_gateway.gw2: Creating...
aws_nat_gateway.gw1: Creating...
aws_route_table_association.public-ap-south-1b: Creation complete after 0s [id=rtbassoc-03d0f6fb363d7cd96]
aws_route_table_association.public-ap-south-1a: Creation complete after 0s [id=rtbassoc-0d9c23d47ecc9891e]
aws_eks_cluster.demo: Still creating... [10s elapsed]
aws_nat_gateway.gw2: Still creating... [10s elapsed]
aws_nat_gateway.gw1: Still creating... [10s elapsed]
aws_eks_cluster.demo: Still creating... [20s elapsed]
aws_nat_gateway.gw2: Still creating... [20s elapsed]
aws_nat_gateway.gw1: Still creating... [20s elapsed]
aws_eks_cluster.demo: Still creating... [30s elapsed]
aws_nat_gateway.gw2: Still creating... [30s elapsed]
aws_nat_gateway.gw1: Still creating... [30s elapsed]
aws_eks_cluster.demo: Still creating... [40s elapsed]
aws_nat_gateway.gw2: Still creating... [40s elapsed]
aws_nat_gateway.gw1: Still creating... [40s elapsed]
aws_eks_cluster.demo: Still creating... [50s elapsed]
aws_nat_gateway.gw2: Still creating... [50s elapsed]
aws_nat_gateway.gw1: Still creating... [50s elapsed]
aws_eks_cluster.demo: Still creating... [1m0s elapsed]
aws_nat_gateway.gw2: Still creating... [1m0s elapsed]
aws_nat_gateway.gw1: Still creating... [1m0s elapsed]
aws_eks_cluster.demo: Still creating... [1m10s elapsed]
aws_nat_gateway.gw2: Still creating... [1m10s elapsed]
aws_nat_gateway.gw1: Still creating... [1m10s elapsed]
aws_eks_cluster.demo: Still creating... [1m20s elapsed]
aws_nat_gateway.gw2: Still creating... [1m20s elapsed]
aws_nat_gateway.gw1: Still creating... [1m20s elapsed]
aws_eks_cluster.demo: Still creating... [1m30s elapsed]
aws_nat_gateway.gw2: Still creating... [1m30s elapsed]
aws_nat_gateway.gw1: Still creating... [1m30s elapsed]
aws_eks_cluster.demo: Still creating... [1m40s elapsed]
aws_nat_gateway.gw2: Still creating... [1m40s elapsed]
aws_nat_gateway.gw1: Still creating... [1m40s elapsed]
aws_eks_cluster.demo: Still creating... [1m50s elapsed]
aws_nat_gateway.gw2: Still creating... [1m50s elapsed]
aws_nat_gateway.gw1: Still creating... [1m50s elapsed]
aws_eks_cluster.demo: Still creating... [2m0s elapsed]
aws_nat_gateway.gw2: Still creating... [2m0s elapsed]
aws_nat_gateway.gw1: Still creating... [2m0s elapsed]
aws_nat_gateway.gw1: Creation complete after 2m4s [id=nat-086392166cb7e04a1]
aws_route_table.private1: Creating...
aws_route_table.private1: Creation complete after 1s [id=rtb-02b14d41b751a9ac6]
aws_route_table_association.private-ap-south-1a: Creating...
aws_route_table_association.private-ap-south-1a: Creation complete after 0s [id=rtbassoc-0f3ee6c75d4b252e9]
aws_nat_gateway.gw2: Creation complete after 2m5s [id=nat-0e8d9219e7e73558d]
aws_route_table.private2: Creating...
aws_route_table.private2: Creation complete after 1s [id=rtb-0feec6b0dae6efd6a]
aws_route_table_association.private-ap-south-1b: Creating...
aws_route_table_association.private-ap-south-1b: Creation complete after 0s [id=rtbassoc-0961add3489d41d63]
aws_eks_cluster.demo: Still creating... [2m10s elapsed]
aws_eks_cluster.demo: Still creating... [2m20s elapsed]
aws_eks_cluster.demo: Still creating... [2m30s elapsed]
aws_eks_cluster.demo: Still creating... [2m40s elapsed]
aws_eks_cluster.demo: Still creating... [2m50s elapsed]
aws_eks_cluster.demo: Still creating... [3m0s elapsed]
aws_eks_cluster.demo: Still creating... [3m10s elapsed]
aws_eks_cluster.demo: Still creating... [3m20s elapsed]
aws_eks_cluster.demo: Still creating... [3m30s elapsed]
aws_eks_cluster.demo: Still creating... [3m40s elapsed]
aws_eks_cluster.demo: Still creating... [3m50s elapsed]
aws_eks_cluster.demo: Still creating... [4m0s elapsed]
aws_eks_cluster.demo: Still creating... [4m10s elapsed]
aws_eks_cluster.demo: Still creating... [4m20s elapsed]
aws_eks_cluster.demo: Still creating... [4m30s elapsed]
aws_eks_cluster.demo: Still creating... [4m40s elapsed]
aws_eks_cluster.demo: Still creating... [4m50s elapsed]
aws_eks_cluster.demo: Still creating... [5m0s elapsed]
aws_eks_cluster.demo: Still creating... [5m10s elapsed]
aws_eks_cluster.demo: Still creating... [5m20s elapsed]
aws_eks_cluster.demo: Still creating... [5m30s elapsed]
aws_eks_cluster.demo: Still creating... [5m40s elapsed]
aws_eks_cluster.demo: Still creating... [5m50s elapsed]
aws_eks_cluster.demo: Still creating... [6m0s elapsed]
aws_eks_cluster.demo: Still creating... [6m10s elapsed]
aws_eks_cluster.demo: Still creating... [6m20s elapsed]
aws_eks_cluster.demo: Still creating... [6m30s elapsed]
aws_eks_cluster.demo: Still creating... [6m40s elapsed]
aws_eks_cluster.demo: Still creating... [6m50s elapsed]
aws_eks_cluster.demo: Still creating... [7m0s elapsed]
aws_eks_cluster.demo: Still creating... [7m10s elapsed]
aws_eks_cluster.demo: Still creating... [7m20s elapsed]
aws_eks_cluster.demo: Still creating... [7m30s elapsed]
aws_eks_cluster.demo: Still creating... [7m40s elapsed]
aws_eks_cluster.demo: Still creating... [7m50s elapsed]
aws_eks_cluster.demo: Still creating... [8m0s elapsed]
aws_eks_cluster.demo: Still creating... [8m10s elapsed]
aws_eks_cluster.demo: Still creating... [8m20s elapsed]
aws_eks_cluster.demo: Creation complete after 8m20s [id=demo]
aws_eks_node_group.private-nodes: Creating...
aws_eks_node_group.private-nodes: Still creating... [10s elapsed]
aws_eks_node_group.private-nodes: Still creating... [20s elapsed]
aws_eks_node_group.private-nodes: Still creating... [30s elapsed]
aws_eks_node_group.private-nodes: Still creating... [40s elapsed]
aws_eks_node_group.private-nodes: Still creating... [50s elapsed]
aws_eks_node_group.private-nodes: Still creating... [1m0s elapsed]
aws_eks_node_group.private-nodes: Still creating... [1m10s elapsed]
aws_eks_node_group.private-nodes: Still creating... [1m20s elapsed]
aws_eks_node_group.private-nodes: Still creating... [1m30s elapsed]
aws_eks_node_group.private-nodes: Still creating... [1m40s elapsed]
aws_eks_node_group.private-nodes: Creation complete after 1m49s [id=demo:private-nodes]

Apply complete! Resources: 25 added, 0 changed, 0 destroyed.

Outputs:

vpc_id = vpc-02d109b2d9081bd41
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ ll
total 12228
-rwxrwxr-x 1 terraform terraform      506 Jun 12 07:06 10-aws-test.yaml
-rwxrwxr-x 1 terraform terraform      867 Jun 12 07:07 11-deployment.yaml
-rwxrwxr-x 1 terraform terraform      256 Jun 12 07:08 12-public-lb.yaml
-rwxrwxr-x 1 terraform terraform      326 Jun 12 07:08 13-private-lb.yaml
-rwxrwxr-x 1 terraform terraform     1631 Jun 12 07:09 14-iam-autoscaler
-rwxrwxr-x 1 terraform terraform      105 Jun 12 11:13 2-igw.tf
-rwxrwxr-x 1 terraform terraform      215 Jun 12 06:56 2_provider.tf
-rwxrwxr-x 1 terraform terraform      232 Jun 12 11:04 2_vpc.tf
-rwxrwxr-x 1 terraform terraform     1400 Jun 12 11:38 3-subnets.tf
-rwxrwxr-x 1 terraform terraform      151 Jun 12 11:44 4_eips.tf
-rwxrwxr-x 1 terraform terraform      315 Jun 12 12:08 4-nat.tf
-rwxrwxr-x 1 terraform terraform     1515 Jun 12 13:24 5-routes.tf
-rwxrwxr-x 1 terraform terraform      844 Jun 12 13:34 6-eks.tf
-rwxrwxr-x 1 terraform terraform      970 Jun 12 13:30 6-eks.tf.bkp
-rwxrwxr-x 1 terraform terraform      656 Jun 12 12:36 6-route-table-association.tf
-rwxrwxr-x 1 terraform terraform     2104 Jun 12 14:00 7-nodes.tf
-rwxrwxr-x 1 terraform terraform      352 Jun 12 08:07 8-iam-oidc
-rwxrwxr-x 1 terraform terraform     1155 Jun 12 07:04 9-iam-test
-rwxrwxr-x 1 terraform terraform    11156 Jun 12 15:22 get_helm.sh
-rwxrwxr-x 1 terraform terraform 12378363 Apr 14  2021 helm.tar.gz
-rwxrwxr-x 1 terraform terraform       64 Jun 12 08:31 kubectl.sha256
drwxrwxr-x 2 terraform terraform     4096 Jun 12 15:24 linux-amd64
-rwxrwxr-x 1 terraform terraform       60 Jun 12 16:17 monitoring.yml
-rwxrwxr-x 1 terraform terraform    34746 Jun 15 10:54 terraform.tfstate
-rwxrwxr-x 1 terraform terraform      158 Jun 15 10:44 terraform.tfstate.backup
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ aws eks --region us-east-1 update-kubeconfig --name demo

An error occurred (UnrecognizedClientException) when calling the DescribeCluster operation: The security token included in the request is invalid.
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ aws eks --region ap-south-1 update-kubeconfig --name demo

An error occurred (UnrecognizedClientException) when calling the DescribeCluster operation: The security token included in the request is invalid.
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ kubectl get svc
Unable to connect to the server: dial tcp: lookup 3079C742C65FF068B34AFC259FDCAF83.gr7.ap-south-1.eks.amazonaws.com on 192.168.0.2:53: no such host
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ _eks_node_group.private-nodes: Still creating... [1m10s elapsed]
aws_eks_node_group.private-nodes: Creation complete after 1m49s [id=demo:private-nodes]

Apply complete! Resources: 25 added, 0 changed, 0 destroyed.

Outputs:

vpc_id = vpc-02d109b2d9081bd41
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$-bash: _eks_node_group.private-nodes:: command not found
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ aws_eks_node_group.private-nodes: Still creating... [1m20s elapsed]
-bash: aws_eks_node_group.private-nodes:: command not found
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ aws_eks_node_group.private-nodes: Still creating... [1m30s elapsed]
-bash: aws_eks_node_group.private-nodes:: command not found
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ aws_eks_node_group.private-nodes: Still creating... [1m40s elapsed]
-bash: aws_eks_node_group.private-nodes:: command not found
[terraform@ip-192-168-82-43 Terraform_EKS_Prod]$ aws_eks_node_group.private-nodes: Creation complete after 1m49s [id=demo:private-nodes]
-bash: aws_eks_node_group.private-nodes:: command not found
